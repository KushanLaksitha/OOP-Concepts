<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Intermediate Practical Questions Set 3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); /* New Blue Gradient */
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .question-block {
            margin-bottom: 40px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .question-block:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        
        .question-header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .question-header:hover {
            background: linear-gradient(135deg, #2d7fb2 0%, #226996 100%);
        }
        
        .question-title {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .toggle-icon {
            font-size: 1.5em;
            transition: transform 0.3s ease;
        }
        
        .question-header.active .toggle-icon {
            transform: rotate(180deg);
        }
        
        .answer-section {
            display: none;
            padding: 20px;
            background: #f9f9f9;
        }
        
        .answer-section.active {
            display: block;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        code {
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.8;
        }
        
        .explanation {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #2980b9;
        }
        
        .explanation h4 {
            color: #2980b9;
            margin-bottom: 10px;
        }
        
        .expand-all-btn {
            background: white;
            color: #3498db;
            border: 2px solid white;
            padding: 10px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.3s ease;
        }
        
        .expand-all-btn:hover {
            background: #3498db;
            color: white;
            transform: scale(1.05);
        }
        
        /* Syntax Highlighting Colors (Dracula theme inspired) */
        .keyword {
            color: #ff79c6; /* Pink */
        }
        
        .function {
            color: #50fa7b; /* Green */
        }
        
        .string {
            color: #f1fa8c; /* Yellow */
        }
        
        .comment {
            color: #6272a4; /* Gray-blue */
            font-style: italic;
        }
        
        .number {
            color: #bd93f9; /* Purple */
        }
        
        .type {
            color: #8be9fd; /* Cyan */
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>⚙️ C++ Intermediate Practical Questions Set 3</h1>
            <p class="subtitle">OOP, Strings, and Fundamental Logic</p>
            <button class="expand-all-btn" onclick="toggleAll()">Expand All Answers</button>
        </header>
        
        <div class="content">
            <!-- Question 1 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(1)">
                    <span class="question-title">1. Write a program to find the largest of three numbers using a macro definition</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-1">
                    <pre><code><span class="comment">// Macro for Finding Largest Number</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Define a macro to find the largest of two numbers first</span>
<span class="keyword">#define MAX2(a, b) ((a) > (b) ? (a) : (b))</span>

<span class="comment">// Define a macro to find the largest of three numbers using MAX2</span>
<span class="keyword">#define MAX3(a, b, c) MAX2(MAX2(a, b), c)</span>

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> n1 = <span class="number">10</span>, n2 = <span class="number">50</span>, n3 = <span class="number">30</span>;
    
    <span class="comment">// The preprocessor replaces MAX3(n1, n2, n3) with the full conditional expression</span>
    <span class="keyword">int</span> largest = MAX3(n1, n2, n3);
    
    cout &lt;&lt; <span class="string">"The largest number among "</span> &lt;&lt; n1 &lt;&lt; <span class="string">", "</span> &lt;&lt; n2 
         &lt;&lt; <span class="string">", and "</span> &lt;&lt; n3 &lt;&lt; <span class="string">" is: "</span> &lt;&lt; largest &lt;&lt; endl;
    
    <span class="comment">// Note the mandatory parentheses in the macro to avoid side effects</span>
    <span class="keyword">int</span> x = <span class="number">5</span>;
    <span class="keyword">int</span> y = <span class="number">10</span>;
    cout &lt;&lt; <span class="string">"Largest of x and y: "</span> &lt;&lt; MAX2(x, y) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>A macro (defined using <code>#define</code>) is a preprocessor directive that performs simple text substitution before compilation. It's often used for constant definition or simple inline functions. Here, the conditional operator (<code>? :</code>) is used within the macro to determine the largest value. Parentheses are essential to ensure correct operator precedence.</p>
                    </div>
                </div>
            </div>

            <!-- Question 2 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(2)">
                    <span class="question-title">2. Implement a C++ program to check if a number is an Amicable Pair with another given number</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-2">
                    <pre><code><span class="comment">// Amicable Numbers Check</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Function to calculate the sum of proper divisors of a number</span>
<span class="keyword">int</span> <span class="function">sumOfProperDivisors</span>(<span class="keyword">int</span> n) {
    <span class="keyword">int</span> sum = <span class="number">1</span>; <span class="comment">// Start with 1 as every number is divisible by 1</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) {
        <span class="keyword">if</span> (n % i == <span class="number">0</span>) {
            sum += i;
            <span class="comment">// Also add the corresponding divisor (n/i), unless it's a perfect square</span>
            <span class="keyword">if</span> (i * i != n) {
                sum += (n / i);
            }
        }
    }
    <span class="keyword">return</span> sum;
}

<span class="keyword">bool</span> <span class="function">areAmicable</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) {
    <span class="comment">// Amicable Pair condition: sum(divisors of a) = b AND sum(divisors of b) = a, AND a != b</span>
    <span class="keyword">return</span> (sumOfProperDivisors(a) == b &amp;&amp; sumOfProperDivisors(b) == a &amp;&amp; a != b);
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> n1 = <span class="number">220</span>; <span class="comment">// Divisors sum to 284</span>
    <span class="keyword">int</span> n2 = <span class="number">284</span>; <span class="comment">// Divisors sum to 220</span>
    <span class="keyword">int</span> n3 = <span class="number">300</span>;
    
    cout &lt;&lt; <span class="string">"Are "</span> &lt;&lt; n1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; n2 &lt;&lt; <span class="string">" amicable? "</span> &lt;&lt; (areAmicable(n1, n2) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Are "</span> &lt;&lt; n1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; n3 &lt;&lt; <span class="string">" amicable? "</span> &lt;&lt; (areAmicable(n1, n3) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>Two numbers, $a$ and $b$, are an amicable pair if the sum of the proper positive divisors of $a$ equals $b$, and the sum of the proper positive divisors of $b$ equals $a$, where $a \neq b$. The <code>sumOfProperDivisors</code> function efficiently calculates this sum by only checking divisors up to the square root of $n$.</p>
                    </div>
                </div>
            </div>

            <!-- Question 3 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(3)">
                    <span class="question-title">3. Create a <code>Matrix</code> class and overload the binary <code>+</code> operator for matrix addition</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-3">
                    <pre><code><span class="comment">// Operator Overloading: Matrix Addition</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">const int</span> SIZE = <span class="number">2</span>;

<span class="keyword">class</span> Matrix {
<span class="keyword">private</span>:
    <span class="keyword">int</span> mat[SIZE][SIZE];

<span class="keyword">public</span>:
    <span class="comment">// Constructor to initialize matrix</span>
    Matrix(<span class="keyword">int</span> m[SIZE][SIZE]) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE; j++) {
                mat[i][j] = m[i][j];
            }
        }
    }
    
    <span class="comment">// Overload the binary + operator as a member function</span>
    Matrix <span class="function">operator+</span>(<span class="keyword">const</span> Matrix&amp; other) <span class="keyword">const</span> {
        <span class="comment">// Create a temporary matrix for the result</span>
        <span class="keyword">int</span> tempMat[SIZE][SIZE];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE; j++) {
                tempMat[i][j] = <span class="keyword">this</span>-&gt;mat[i][j] + other.mat[i][j];
            }
        }
        <span class="comment">// Return a new Matrix object constructed from the result array</span>
        <span class="keyword">return</span> Matrix(tempMat); 
    }
    
    <span class="keyword">void</span> <span class="function">display</span>() <span class="keyword">const</span> {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE; j++) {
                cout &lt;&lt; mat[i][j] &lt;&lt; <span class="string">"\t"</span>;
            }
            cout &lt;&lt; endl;
        }
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> m1[SIZE][SIZE] = {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}};
    <span class="keyword">int</span> m2[SIZE][SIZE] = {{<span class="number">5</span>, <span class="number">6</span>}, {<span class="number">7</span>, <span class="number">8</span>}};
    
    Matrix A(m1);
    Matrix B(m2);
    
    <span class="comment">// Use the overloaded + operator: C = A.operator+(B)</span>
    Matrix C = A + B;
    
    cout &lt;&lt; <span class="string">"Matrix A + B is:"</span> &lt;&lt; endl;
    C.display();
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>Operator overloading allows operators to work with user-defined types (like the <code>Matrix</code> class). The binary <code>+</code> operator is overloaded as a member function, taking one <code>const Matrix&amp;</code> argument (the right-hand operand). It calculates the element-wise sum and returns a new <code>Matrix</code> object containing the result.</p>
                    </div>
                </div>
            </div>

            <!-- Question 4 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(4)">
                    <span class="question-title">4. Demonstrate the concept of Function Overriding using a Base and a Derived class</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-4">
                    <pre><code><span class="comment">// Function Overriding (Basic Polymorphism)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Base Class</span>
<span class="keyword">class</span> Vehicle {
<span class="keyword">public</span>:
    <span class="comment">// Base class function to be overridden. Use 'virtual' for runtime polymorphism.</span>
    <span class="keyword">virtual void</span> <span class="function">start</span>() <span class="keyword">const</span> {
        cout &lt;&lt; <span class="string">"Vehicle engine starts."</span> &lt;&lt; endl;
    }
    <span class="keyword">virtual</span> ~Vehicle() {}
};

<span class="comment">// Derived Class</span>
<span class="keyword">class</span> Car : <span class="keyword">public</span> Vehicle {
<span class="keyword">public</span>:
    <span class="comment">// Overriding the base class function (using 'override' is optional but recommended)</span>
    <span class="keyword">void</span> <span class="function">start</span>() <span class="keyword">const override</span> {
        cout &lt;&lt; <span class="string">"Car key turned, Vroom!"</span> &lt;&lt; endl;
    }
};

<span class="comment">// Another Derived Class</span>
<span class="keyword">class</span> Bicycle : <span class="keyword">public</span> Vehicle {
<span class="keyword">public</span>:
    <span class="keyword">void</span> <span class="function">start</span>() <span class="keyword">const override</span> {
        cout &lt;&lt; <span class="string">"Bicycle starts by pedaling."</span> &lt;&lt; endl;
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Base class pointer pointing to derived class objects</span>
    Vehicle* v1 = <span class="keyword">new</span> Car();
    Vehicle* v2 = <span class="keyword">new</span> Bicycle();
    
    <span class="comment">// Virtual function call (runtime polymorphism)</span>
    v1-&gt;start(); <span class="comment">// Calls Car::start()</span>
    v2-&gt;start(); <span class="comment">// Calls Bicycle::start()</span>
    
    <span class="keyword">delete</span> v1;
    <span class="keyword">delete</span> v2;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>Function overriding occurs when a derived class defines a function with the exact same signature (name, parameters, const-ness) as a virtual function in its base class. By using a base class pointer to hold a derived class object, the appropriate derived class function is called at runtime, demonstrating runtime polymorphism.</p>
                    </div>
                </div>
            </div>

            <!-- Question 5 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(5)">
                    <span class="question-title">5. Implement a function to calculate the Factorial of a number iteratively</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-5">
                    <pre><code><span class="comment">// Factorial Calculation (Iterative)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Function to calculate factorial using a loop</span>
<span class="keyword">long long</span> <span class="function">factorialIterative</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) {
        cout &lt;&lt; <span class="string">"Error: Factorial of negative number is undefined."</span> &lt;&lt; endl;
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="number">1</span>;
    }
    
    <span class="keyword">long long</span> result = <span class="number">1</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {
        result *= i;
    }
    
    <span class="keyword">return</span> result;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> num = <span class="number">10</span>;
    <span class="keyword">int</span> numSmall = <span class="number">5</span>;
    
    cout &lt;&lt; <span class="string">"Factorial of "</span> &lt;&lt; numSmall &lt;&lt; <span class="string">": "</span> &lt;&lt; factorialIterative(numSmall) &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Factorial of "</span> &lt;&lt; num &lt;&lt; <span class="string">": "</span> &lt;&lt; factorialIterative(num) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>The factorial of a non-negative integer $n$ is the product of all positive integers less than or equal to $n$. The iterative solution uses a simple <code>for</code> loop to multiply the result starting from 1 up to $n$. Using <code>long long</code> is important to prevent overflow for larger factorial calculations.</p>
                    </div>
                </div>
            </div>

            <!-- Question 6 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(6)">
                    <span class="question-title">6. Write a program to count the total number of words in a given sentence/string</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-6">
                    <pre><code><span class="comment">// Word Count in a String</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">include</span> &lt;sstream&gt; <span class="comment">// For stringstream</span>
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">countWords</span>(<span class="keyword">const string</span>&amp; sentence) {
    <span class="keyword">if</span> (sentence.empty()) {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    
    <span class="type">stringstream</span> ss(sentence);
    <span class="keyword">string</span> word;
    <span class="keyword">int</span> count = <span class="number">0</span>;
    
    <span class="comment">// The extraction operator >> reads words delimited by whitespace</span>
    <span class="keyword">while</span> (ss &gt;&gt; word) {
        count++;
    }
    
    <span class="keyword">return</span> count;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">string</span> text1 = <span class="string">"This is a sample sentence with six words."</span>;
    <span class="keyword">string</span> text2 = <span class="string">"Single"</span>;
    <span class="keyword">string</span> text3 = <span class="string">""</span>;
    
    cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; text1 &lt;&lt; <span class="string">"\" has "</span> &lt;&lt; countWords(text1) &lt;&lt; <span class="string">" words."</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; text2 &lt;&lt; <span class="string">"\" has "</span> &lt;&lt; countWords(text2) &lt;&lt; <span class="string">" word."</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; text3 &lt;&lt; <span class="string">"\" has "</span> &lt;&lt; countWords(text3) &lt;&lt; <span class="string">" words."</span> &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>The most elegant C++ way to count words is to use an <code>std::stringstream</code>. The stream extraction operator (<code>>></code>) naturally tokenizes a string based on whitespace, allowing the <code>while (ss >> word)</code> loop to efficiently extract each word and increment the counter.</p>
                    </div>
                </div>
            </div>

            <!-- Question 7 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(7)">
                    <span class="question-title">7. Implement a function to find the maximum element in an array using an Iterator (or Pointer)</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-7">
                    <pre><code><span class="comment">// Max Element using Pointer Iteration</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">findMaxPointer</span>(<span class="keyword">const int</span>* start, <span class="keyword">int</span> size) {
    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) {
        <span class="keyword">return</span> -<span class="number">1</span>;
    }
    
    <span class="comment">// Initialize max value with the first element</span>
    <span class="keyword">int</span> maxVal = *start; 
    <span class="comment">// Define the end point (one past the last element)</span>
    <span class="keyword">const int</span>* end = start + size; 
    
    <span class="comment">// Iterate using the pointer (simulating an iterator)</span>
    <span class="keyword">for</span> (<span class="keyword">const int</span>* p = start + <span class="number">1</span>; p != end; p++) {
        <span class="comment">// Dereference the pointer to get the value</span>
        <span class="keyword">if</span> (*p &gt; maxVal) {
            maxVal = *p;
        }
    }
    
    <span class="keyword">return</span> maxVal;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> numbers[] = {<span class="number">22</span>, <span class="number">55</span>, <span class="number">11</span>, <span class="number">99</span>, <span class="number">33</span>};
    <span class="keyword">int</span> n = <span class="number">5</span>;
    
    cout &lt;&lt; <span class="string">"The maximum element is: "</span> &lt;&lt; findMaxPointer(numbers, n) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This program demonstrates array traversal using raw pointers, which mirrors how iterators work in the STL. The function takes a starting pointer (`start`) and the `size`. It calculates the `end` pointer (one past the last element). The loop then uses pointer increments (<code>p++</code>) to move through the array, accessing values via dereferencing (<code>*p</code>).</p>
                    </div>
                </div>
            </div>

            <!-- Question 8 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(8)">
                    <span class="question-title">8. Write a program to calculate the area of a trapezoid using a friend function</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-8">
                    <pre><code><span class="comment">// Friend Function Demonstration</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">class</span> Trapezoid {
<span class="keyword">private</span>:
    <span class="keyword">double</span> base1;
    <span class="keyword">double</span> base2;
    <span class="keyword">double</span> height;

<span class="keyword">public</span>:
    Trapezoid(<span class="keyword">double</span> b1, <span class="keyword">double</span> b2, <span class="keyword">double</span> h) 
        : base1(b1), base2(b2), height(h) {}

    <span class="comment">// Declaration of a friend function (non-member)</span>
    <span class="keyword">friend double</span> <span class="function">calculateTrapezoidArea</span>(<span class="keyword">const</span> Trapezoid&amp; t);
};

<span class="comment">// Definition of the friend function outside the class</span>
<span class="comment">// Formula: Area = 0.5 * (base1 + base2) * height</span>
<span class="keyword">double</span> <span class="function">calculateTrapezoidArea</span>(<span class="keyword">const</span> Trapezoid&amp; t) {
    <span class="comment">// Direct access to private members is allowed</span>
    <span class="keyword">return</span> <span class="number">0.5</span> * (t.base1 + t.base2) * t.height;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    Trapezoid t(<span class="number">10.0</span>, <span class="number">20.0</span>, <span class="number">5.0</span>);
    
    <span class="comment">// Call the friend function</span>
    <span class="keyword">double</span> area = calculateTrapezoidArea(t);
    
    cout &lt;&lt; <span class="string">"Trapezoid Area: "</span> &lt;&lt; area &lt;&lt; endl; <span class="comment">// Expected: 0.5 * (30) * 5 = 75.0</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>A friend function is a non-member function that is granted access to the private and protected members of a class. The <code>calculateTrapezoidArea</code> function is declared <code>friend</code> inside the <code>Trapezoid</code> class, allowing it to directly access <code>base1</code>, <code>base2</code>, and <code>height</code> without using public getter methods, while maintaining the encapsulation of the class from other external functions.</p>
                    </div>
                </div>
            </div>

            <!-- Question 9 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(9)">
                    <span class="question-title">9. Write a function to check if a string contains any duplicate characters</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-9">
                    <pre><code><span class="comment">// Check for Duplicate Characters in a String</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">include</span> &lt;algorithm&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Assuming ASCII character set (256 characters)</span>
<span class="keyword">const int</span> ASCII_SIZE = <span class="number">256</span>;

<span class="keyword">bool</span> <span class="function">hasDuplicates</span>(<span class="keyword">const string</span>&amp; str) {
    <span class="comment">// Trivial case: If string length is greater than the character set size, duplicates must exist</span>
    <span class="keyword">if</span> (str.length() &gt; ASCII_SIZE) {
        <span class="keyword">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// Boolean array to track character presence</span>
    <span class="keyword">bool</span> char_set[ASCII_SIZE] = {<span class="keyword">false</span>}; 
    
    <span class="keyword">for</span> (<span class="keyword">char</span> ch : str) {
        <span class="keyword">int</span> ascii_val = (<span class="keyword">int</span>)ch;
        
        <span class="comment">// If character is already marked, it's a duplicate</span>
        <span class="keyword">if</span> (char_set[ascii_val]) {
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        
        <span class="comment">// Mark the character as present</span>
        char_set[ascii_val] = <span class="keyword">true</span>;
    }

    <span class="keyword">return</span> <span class="keyword">false</span>;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">string</span> s1 = <span class="string">"abcdefg"</span>;
    <span class="keyword">string</span> s2 = <span class="string">"programming"</span>;
    
    cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; s1 &lt;&lt; <span class="string">"\" has duplicates: "</span> &lt;&lt; (hasDuplicates(s1) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; s2 &lt;&lt; <span class="string">"\" has duplicates: "</span> &lt;&lt; (hasDuplicates(s2) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This solution uses a boolean array as a hash set (frequency map) to efficiently track the presence of each character. It iterates through the string once (O(n)). For each character, it checks if the corresponding index in <code>char_set</code> is already true. If so, a duplicate is found. Otherwise, it marks the character as seen.</p>
                    </div>
                </div>
            </div>

            <!-- Question 10 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(10)">
                    <span class="question-title">10. Create a class <code>Employee</code> with data members and a function to calculate the net salary after tax deduction</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-10">
                    <pre><code><span class="comment">// Employee Salary Calculation Class</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">include</span> &lt;iomanip&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">class</span> Employee {
<span class="keyword">private</span>:
    <span class="keyword">string</span> name;
    <span class="keyword">double</span> grossSalary;
    <span class="keyword">const double</span> TAX_RATE = <span class="number">0.15</span>; <span class="comment">// 15% tax rate</span>

<span class="keyword">public</span>:
    Employee(<span class="keyword">string</span> n, <span class="keyword">double</span> gs) : name(n), grossSalary(gs) {}
    
    <span class="keyword">double</span> <span class="function">calculateNetSalary</span>() <span class="keyword">const</span> {
        <span class="keyword">double</span> taxAmount = grossSalary * TAX_RATE;
        <span class="keyword">return</span> grossSalary - taxAmount;
    }
    
    <span class="keyword">void</span> <span class="function">displaySalaryDetails</span>() <span class="keyword">const</span> {
        cout &lt;&lt; <span class="function">fixed</span> &lt;&lt; <span class="function">setprecision</span>(<span class="number">2</span>);
        cout &lt;&lt; <span class="string">"Employee: "</span> &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; <span class="string">"Gross Salary: $"</span> &lt;&lt; grossSalary &lt;&lt; endl;
        cout &lt;&lt; <span class="string">"Tax Deducted ("</span> &lt;&lt; TAX_RATE * <span class="number">100</span> &lt;&lt; <span class="string">"%): $"</span> &lt;&lt; grossSalary * TAX_RATE &lt;&lt; endl;
        cout &lt;&lt; <span class="string">"Net Salary: $"</span> &lt;&lt; calculateNetSalary() &lt;&lt; endl;
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    Employee emp(<span class="string">"Robert Downey"</span>, <span class="number">50000.00</span>);
    emp.displaySalaryDetails();
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This class models a real-world entity with data (name, salary) and behavior (calculating net salary). The <code>TAX_RATE</code> is defined as a <code>const double</code> within the class. The <code>calculateNetSalary</code> method encapsulates the business logic, promoting data integrity by keeping <code>grossSalary</code> private.</p>
                    </div>
                </div>
            </div>

            <!-- Question 11 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(11)">
                    <span class="question-title">11. Write a program to find the second largest element in an array in a single pass</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-11">
                    <pre><code><span class="comment">// Second Largest Element (Single Pass)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;limits&gt; <span class="comment">// For INT_MIN</span>
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">findSecondLargest</span>(<span class="keyword">const int</span> arr[], <span class="keyword">int</span> size) {
    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) {
        cout &lt;&lt; <span class="string">"Error: Array must have at least two elements."</span> &lt;&lt; endl;
        <span class="keyword">return</span> <span class="number">0</span>;
    }

    <span class="comment">// Initialize both to the smallest possible integer value</span>
    <span class="keyword">int</span> first = <span class="function">numeric_limits</span>&lt;<span class="keyword">int</span>&gt;::min();
    <span class="keyword">int</span> second = <span class="function">numeric_limits</span>&lt;<span class="keyword">int</span>&gt;::min();

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {
        <span class="keyword">if</span> (arr[i] &gt; first) {
            <span class="comment">// Found a new largest element, so old first becomes second</span>
            second = first;
            first = arr[i];
        } <span class="keyword">else if</span> (arr[i] &gt; second &amp;&amp; arr[i] != first) {
            <span class="comment">// Found a value that is between first and second</span>
            second = arr[i];
        }
    }
    
    <span class="keyword">if</span> (second == <span class="function">numeric_limits</span>&lt;<span class="keyword">int</span>&gt;::min()) {
        cout &lt;&lt; <span class="string">"All elements are the same."</span> &lt;&lt; endl;
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    
    <span class="keyword">return</span> second;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> arr[] = {<span class="number">12</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">34</span>, <span class="number">1</span>};
    <span class="keyword">int</span> n = <span class="number">6</span>;
    
    cout &lt;&lt; <span class="string">"Second largest element: "</span> &lt;&lt; findSecondLargest(arr, n) &lt;&lt; endl; <span class="comment">// Expected: 34</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This solution finds the second largest element in a single pass (O(n)) without sorting. It tracks both the largest element (`first`) and the second largest (`second`). When a new largest element is found, the old `first` is moved to `second`. Otherwise, if an element is smaller than `first` but larger than `second`, it becomes the new `second`.</p>
                    </div>
                </div>
            </div>

            <!-- Question 12 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(12)">
                    <span class="question-title">12. Write a program to find the greatest common prefix (GCP) among a set of strings</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-12">
                    <pre><code><span class="comment">// Longest Common Prefix (LCP)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;vector&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">include</span> &lt;algorithm&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">string</span> <span class="function">longestCommonPrefix</span>(<span class="keyword">const vector</span>&lt;<span class="keyword">string</span>&gt;&amp; strs) {
    <span class="keyword">if</span> (strs.empty()) {
        <span class="keyword">return</span> <span class="string">""</span>;
    }
    
    <span class="comment">// Start with the first string as the initial prefix</span>
    <span class="keyword">string</span> prefix = strs[<span class="number">0</span>];
    
    <span class="comment">// Compare the prefix with all subsequent strings</span>
    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; strs.size(); i++) {
        <span class="comment">// Reduce the prefix until it is found at the beginning of strs[i]</span>
        <span class="keyword">while</span> (strs[i].find(prefix) != <span class="number">0</span>) {
            <span class="comment">// Shorten the prefix by one character from the end</span>
            prefix = prefix.substr(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);
            
            <span class="comment">// If prefix becomes empty, there is no common prefix</span>
            <span class="keyword">if</span> (prefix.empty()) {
                <span class="keyword">return</span> <span class="string">""</span>;
            }
        }
    }

    <span class="keyword">return</span> prefix;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="type">vector</span>&lt;<span class="keyword">string</span>&gt; strings = {<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>};
    
    cout &lt;&lt; <span class="string">"LCP of the vector is: "</span> &lt;&lt; longestCommonPrefix(strings) &lt;&lt; endl; <span class="comment">// Expected: fl</span>

    <span class="type">vector</span>&lt;<span class="keyword">string</span>&gt; strings2 = {<span class="string">"dog"</span>, <span class="string">"racecar"</span>, <span class="string">"car"</span>};
    cout &lt;&lt; <span class="string">"LCP of the second vector is: "</span> &lt;&lt; longestCommonPrefix(strings2) &lt;&lt; endl; <span class="comment">// Expected: ""</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This horizontal scanning approach starts by assuming the first string is the common prefix. It then iterates through the rest of the strings. In each step, it shortens the current <code>prefix</code> until it matches the beginning of the current string (checked by <code>string::find</code> returning 0). If the prefix becomes empty, the process stops.</p>
                    </div>
                </div>
            </div>

            <!-- Question 13 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(13)">
                    <span class="question-title">13. Demonstrate the concept of a Copy Constructor</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-13">
                    <pre><code><span class="comment">// Copy Constructor Demonstration</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">class</span> Point {
<span class="keyword">private</span>:
    <span class="keyword">int</span> x;
    <span class="keyword">int</span> y;

<span class="keyword">public</span>:
    <span class="comment">// Parameterized Constructor</span>
    Point(<span class="keyword">int</span> px = <span class="number">0</span>, <span class="keyword">int</span> py = <span class="number">0</span>) : x(px), y(py) {
        cout &lt;&lt; <span class="string">"Parameterized Constructor called."</span> &lt;&lt; endl;
    }
    
    <span class="comment">// Copy Constructor: takes a const reference to an object of the same class</span>
    Point(<span class="keyword">const</span> Point&amp; source) {
        x = source.x;
        y = source.y;
        cout &lt;&lt; <span class="string">"Copy Constructor called."</span> &lt;&lt; endl;
    }

    <span class="keyword">void</span> <span class="function">display</span>() <span class="keyword">const</span> {
        cout &lt;&lt; <span class="string">"Point("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;
    }
};

<span class="comment">// Function to demonstrate passing by value (invokes Copy Constructor)</span>
<span class="keyword">void</span> <span class="function">printPoint</span>(Point p) {
    cout &lt;&lt; <span class="string">"Inside printPoint: "</span>;
    p.display();
}

<span class="keyword">int</span> <span class="function">main</span>() {
    Point original(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// Parameterized Constructor</span>
    
    <span class="comment">// 1. Initialization: Invokes Copy Constructor</span>
    Point copied1 = original;
    
    <span class="comment">// 2. Initialization: Invokes Copy Constructor (direct method)</span>
    Point copied2(original);
    
    cout &lt;&lt; <span class="string">"---"</span> &lt;&lt; endl;
    
    <span class="comment">// 3. Function call: Invokes Copy Constructor (pass by value)</span>
    printPoint(original);

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>A Copy Constructor is a special constructor called when a new object is created from an existing object of the same class. It is invoked during: 1) declaration and initialization (<code>Point p2 = p1;</code> or <code>Point p2(p1);</code>), 2) passing an object by value to a function, and 3) returning an object by value from a function. For classes with dynamic memory, a custom Copy Constructor (Deep Copy) is vital.</p>
                    </div>
                </div>
            </div>

            <!-- Question 14 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(14)">
                    <span class="question-title">14. Write a function to check if a string is a Substring of another string</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-14">
                    <pre><code><span class="comment">// Substring Check</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">bool</span> <span class="function">isSubstring</span>(<span class="keyword">const string</span>&amp; mainStr, <span class="keyword">const string</span>&amp; subStr) {
    <span class="comment">// std::string::find() returns the starting position of the substring</span>
    <span class="comment">// or std::string::npos if not found.</span>
    <span class="keyword">return</span> mainStr.find(subStr) != <span class="keyword">string</span>::npos;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">string</span> mainS = <span class="string">"University of Technology"</span>;
    <span class="keyword">string</span> subS1 = <span class="string">"Tech"</span>;
    <span class="keyword">string</span> subS2 = <span class="string">"Science"</span>;
    
    cout &lt;&lt; <span class="string">"Is '"</span> &lt;&lt; subS1 &lt;&lt; <span class="string">"' a substring of '"</span> &lt;&lt; mainS &lt;&lt; <span class="string">"'? "</span> 
         &lt;&lt; (isSubstring(mainS, subS1) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
         
    cout &lt;&lt; <span class="string">"Is '"</span> &lt;&lt; subS2 &lt;&lt; <span class="string">"' a substring of '"</span> &lt;&lt; mainS &lt;&lt; <span class="string">"'? "</span> 
         &lt;&lt; (isSubstring(mainS, subS2) ? <span class="string">"Yes"</span> : <span class="string">"No"</span>) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>The <code>std::string</code> class provides a built-in <code>find()</code> method for efficient substring searching. The <code>find()</code> method returns the index of the first occurrence of the substring. If the substring is not found, it returns the special value <code>std::string::npos</code> (usually -1). Checking if the return value is not equal to <code>npos</code> confirms the substring's presence.</p>
                    </div>
                </div>
            </div>

            <!-- Question 15 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(15)">
                    <span class="question-title">15. Write a program to implement a simple two-function calculator using a <code>union</code></span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-15">
                    <pre><code><span class="comment">// Union Demonstration (Simple Calculator)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Union to hold either addition or multiplication result</span>
<span class="keyword">union</span> CalcResult {
    <span class="keyword">int</span> sum;
    <span class="keyword">long long</span> product;
};

<span class="comment">// Enum to distinguish which member is currently active</span>
<span class="keyword">enum</span> OperationType {
    ADDITION,
    MULTIPLICATION
};

<span class="keyword">int</span> <span class="function">main</span>() {
    CalcResult result;
    OperationType currentOp;
    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;
    
    <span class="comment">/* --- Perform Addition --- */</span>
    currentOp = ADDITION;
    result.sum = a + b; 
    
    cout &lt;&lt; <span class="string">"Operation: Addition ("</span> &lt;&lt; a &lt;&lt; <span class="string">" + "</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Result (Sum): "</span> &lt;&lt; result.sum &lt;&lt; endl;
    
    <span class="comment">/* --- Perform Multiplication (reusing memory) --- */</span>
    currentOp = MULTIPLICATION;
    result.product = (<span class="keyword">long long</span>)a * b * <span class="number">1000000</span>; <span class="comment">// Using a large number to show long long use</span>

    cout &lt;&lt; <span class="string">"\nOperation: Multiplication ("</span> &lt;&lt; a &lt;&lt; <span class="string">" * "</span> &lt;&lt; b &lt;&lt; <span class="string">" * 1M)"</span> &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Result (Product): "</span> &lt;&lt; result.product &lt;&lt; endl;
    
    <span class="comment">// IMPORTANT: Only the LAST assigned member is guaranteed to be valid.</span>
    <span class="comment">// Accessing result.sum here would lead to garbage data.</span>
    <span class="comment">// The size of the union is the size of its largest member (long long).</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>A <code>union</code> is a special class type where all members share the same memory location. The size of a union is only large enough to hold its largest member. It's used when memory needs to be conserved, and only one member is relevant at any given time. Here, the <code>CalcResult</code> union can store either an <code>int</code> (sum) or a <code>long long</code> (product) in the same memory.</p>
                    </div>
                </div>
            </div>

            <!-- Question 16 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(16)">
                    <span class="question-title">16. Reverse the words in a sentence, keeping the characters in each word intact (e.g., "C++ is fun" -> "fun is C++")</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-16">
                    <pre><code><span class="comment">// Reverse Words in a Sentence</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">include</span> &lt;sstream&gt;
<span class="keyword">include</span> &lt;vector&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">string</span> <span class="function">reverseWords</span>(<span class="keyword">const string</span>&amp; sentence) {
    <span class="type">stringstream</span> ss(sentence);
    <span class="keyword">string</span> word;
    <span class="type">vector</span>&lt;<span class="keyword">string</span>&gt; words;
    
    <span class="comment">// Extract words and store them in a vector</span>
    <span class="keyword">while</span> (ss &gt;&gt; word) {
        words.push_back(word);
    }
    
    <span class="comment">// Rebuild the string in reverse order</span>
    <span class="keyword">string</span> result = <span class="string">""</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = words.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
        result += words[i];
        <span class="comment">// Add a space after every word except the last one</span>
        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {
            result += <span class="string">" "</span>;
        }
    }
    
    <span class="keyword">return</span> result;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">string</span> text = <span class="string">"C++ is fun for University Students"</span>;
    
    cout &lt;&lt; <span class="string">"Original: "</span> &lt;&lt; text &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Reversed: "</span> &lt;&lt; reverseWords(text) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>This solution uses a <code>stringstream</code> to easily tokenize the sentence into individual words, which are stored sequentially in an <code>std::vector&lt;string&gt;</code>. Then, a simple <code>for</code> loop iterates backward through the vector, concatenating the words to form the final reversed sentence.</p>
                    </div>
                </div>
            </div>

            <!-- Question 17 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(17)">
                    <span class="question-title">17. Write a program to find the length of a string without using the built-in <code>length()</code> or <code>size()</code> function</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-17">
                    <pre><code><span class="comment">// String Length without built-in functions</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">include</span> &lt;string&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Function to calculate length of a C-style string (char array)</span>
<span class="keyword">int</span> <span class="function">getStringLength_CStyle</span>(<span class="keyword">const char</span>* s) {
    <span class="keyword">int</span> length = <span class="number">0</span>;
    <span class="comment">// Iterate until the null-terminator ('\0') is found</span>
    <span class="keyword">while</span> (*s != <span class="string">'\0'</span>) {
        length++;
        s++; <span class="comment">// Move the pointer to the next character</span>
    }
    <span class="keyword">return</span> length;
}

<span class="comment">// Function to calculate length of an std::string</span>
<span class="keyword">int</span> <span class="function">getStringLength_StdString</span>(<span class="keyword">const string</span>&amp; s) {
    <span class="keyword">int</span> length = <span class="number">0</span>;
    <span class="comment">// Use a range-based for loop to count elements</span>
    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) {
        length++;
    }
    <span class="keyword">return</span> length;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// 1. C-style string</span>
    <span class="keyword">const char</span>* c_str = <span class="string">"Hello World"</span>;
    cout &lt;&lt; <span class="string">"C-style string length: "</span> &lt;&lt; getStringLength_CStyle(c_str) &lt;&lt; endl;
    
    <span class="comment">// 2. std::string</span>
    <span class="keyword">string</span> std_str = <span class="string">"C++ Programming"</span>;
    cout &lt;&lt; <span class="string">"std::string length: "</span> &lt;&lt; getStringLength_StdString(std_str) &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>For C-style strings (<code>const char*</code>), the length is found by iterating using a pointer until the null-terminator (`\0`) is reached. For <code>std::string</code>, the length can be determined by counting the number of characters in the string, which is simplest using a range-based `for` loop.</p>
                    </div>
                </div>
            </div>

            <!-- Question 18 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(18)">
                    <span class="question-title">18. Implement the concept of Function Pointer to pass a function as an argument</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-18">
                    <pre><code><span class="comment">// Function Pointer as Function Argument</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="comment">// Type definition for the function pointer (improves readability)</span>
<span class="keyword">typedef int</span> (*MathOperation)(<span class="keyword">int</span>, <span class="keyword">int</span>);

<span class="keyword">int</span> <span class="function">add</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) { <span class="keyword">return</span> a + b; }
<span class="keyword">int</span> <span class="function">subtract</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) { <span class="keyword">return</span> a - b; }

<span class="comment">// Function that takes a function pointer as an argument</span>
<span class="keyword">void</span> <span class="function">executeOperation</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MathOperation opPtr) {
    <span class="keyword">int</span> result = opPtr(x, y);
    cout &lt;&lt; <span class="string">"Result: "</span> &lt;&lt; result &lt;&lt; endl;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> n1 = <span class="number">50</span>, n2 = <span class="number">15</span>;
    
    cout &lt;&lt; <span class="string">"Addition Operation: "</span>;
    <span class="comment">// Pass the 'add' function's address</span>
    executeOperation(n1, n2, add); 
    
    cout &lt;&lt; <span class="string">"Subtraction Operation: "</span>;
    <span class="comment">// Pass the 'subtract' function's address</span>
    executeOperation(n1, n2, subtract); 
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>Function pointers allow a function (the callback function) to be passed as an argument to another function. The receiving function (`executeOperation`) uses the pointer to call the actual function (`add` or `subtract`) with its arguments. This is a form of polymorphism often used for implementing flexible callbacks or strategy patterns.</p>
                    </div>
                </div>
            </div>

            <!-- Question 19 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(19)">
                    <span class="question-title">19. Implement a class <code>Temperature</code> and overload the unary <code>-</code> (negation) operator as a member function</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-19">
                    <pre><code><span class="comment">// Unary Operator Overloading (Negation)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">class</span> Temperature {
<span class="keyword">private</span>:
    <span class="keyword">double</span> degrees;

<span class="keyword">public</span>:
    Temperature(<span class="keyword">double</span> d = <span class="number">0.0</span>) : degrees(d) {}
    
    <span class="comment">// Overload the unary - operator as a member function</span>
    Temperature <span class="function">operator-</span>() <span class="keyword">const</span> {
        <span class="comment">// Create and return a new Temperature object with the negated value</span>
        <span class="keyword">return</span> Temperature(-degrees); 
    }

    <span class="keyword">void</span> <span class="function">display</span>() <span class="keyword">const</span> {
        cout &lt;&lt; degrees &lt;&lt; <span class="string">"°C"</span>;
    }
};

<span class="keyword">int</span> <span class="function">main</span>() {
    Temperature t1(<span class="number">25.5</span>);
    
    <span class="comment">// Use the overloaded unary - operator: t2 = t1.operator-()</span>
    Temperature t2 = -t1;
    
    cout &lt;&lt; <span class="string">"Original Temperature: "</span>; t1.display(); cout &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Negated Temperature: "</span>; t2.display(); cout &lt;&lt; endl;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>The unary negation operator (`-`) is overloaded to return a new <code>Temperature</code> object whose internal `degrees` value is the negative of the original. Unary operators overloaded as member functions do not take any explicit arguments, as the operand is the object on which the function is called.</p>
                    </div>
                </div>
            </div>

            <!-- Question 20 -->
            <div class="question-block">
                <div class="question-header" onclick="toggleAnswer(20)">
                    <span class="question-title">20. Implement a function to calculate the $N^{th}$ number in the Fibonacci sequence using iteration</span>
                    <span class="toggle-icon">▼</span>
                </div>
                <div class="answer-section" id="answer-20">
                    <pre><code><span class="comment">// Fibonacci Sequence (Nth Term Iteratively)</span>
<span class="keyword">#include</span> &lt;iostream&gt;
<span class="keyword">using namespace</span> std;

<span class="keyword">long long</span> <span class="function">fibonacciIterative</span>(<span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;

    <span class="comment">// Initialize the first two terms</span>
    <span class="keyword">long long</span> a = <span class="number">0</span>; <span class="comment">// F(0)</span>
    <span class="keyword">long long</span> b = <span class="number">1</span>; <span class="comment">// F(1)</span>
    <span class="keyword">long long</span> next = <span class="number">0</span>;

    <span class="comment">// Calculate terms from F(2) up to F(n)</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {
        next = a + b;
        <span class="comment">// Shift values for the next iteration: F(n-2) becomes F(n-1), F(n-1) becomes F(n)</span>
        a = b;
        b = next;
    }
    <span class="keyword">return</span> next;
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">int</span> n1 = <span class="number">8</span>;
    <span class="keyword">int</span> n2 = <span class="number">12</span>;
    
    cout &lt;&lt; <span class="number">8</span> &lt;&lt; <span class="string">"th Fibonacci number: "</span> &lt;&lt; fibonacciIterative(n1) &lt;&lt; endl; <span class="comment">// F(8) = 21</span>
    cout &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="string">"th Fibonacci number: "</span> &lt;&lt; fibonacciIterative(n2) &lt;&lt; endl; <span class="comment">// F(12) = 144</span>
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>
                    <div class="explanation">
                        <h4>Explanation:</h4>
                        <p>The iterative approach to the Fibonacci sequence is computationally efficient (O(n)) compared to the recursive solution, as it avoids recalculating the same values multiple times. It uses three variables (`a`, `b`, and `next`) to store the current and previous terms, iteratively updating them within a loop.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <!-- Script for Accordion Functionality -->
            <script>
                function toggleAnswer(id) {
                    const answerSection = document.getElementById(`answer-${id}`);
                    const questionHeader = answerSection.previousElementSibling;
                    
                    // Toggle visibility of the answer section
                    answerSection.classList.toggle('active');
                    questionHeader.classList.toggle('active');
                }

                function toggleAll() {
                    const allAnswerSections = document.querySelectorAll('.answer-section');
                    const allQuestionHeaders = document.querySelectorAll('.question-header');
                    const expandButton = document.querySelector('.expand-all-btn');
                    
                    let allExpanded = Array.from(allAnswerSections).every(section => section.classList.contains('active'));
                    
                    allAnswerSections.forEach(section => {
                        if (allExpanded) {
                            section.classList.remove('active');
                        } else {
                            section.classList.add('active');
                        }
                    });

                    allQuestionHeaders.forEach(header => {
                        if (allExpanded) {
                            header.classList.remove('active');
                        } else {
                            header.classList.add('active');
                        }
                    });

                    // Update button text
                    expandButton.textContent = allExpanded ? 'Expand All Answers' : 'Collapse All Answers';
                }
            </script>
        </footer>
    </div>
</body>
</html>