<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>COM 1305 ‚Äî OOP Answer Script</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #fff;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 40px 20px;
      animation: fadeInDown 0.8s ease;
    }

    h1 {
      font-size: 3rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      background: linear-gradient(45deg, #fff, #ffd89b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 1.2rem;
      opacity: 0.9;
    }

    .tabs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin: 30px 0;
      animation: fadeIn 1s ease 0.3s both;
    }

    .tab-btn {
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      padding: 12px 24px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .tab-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .tab-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #fff;
      box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    }

    .content {
      display: none;
      animation: fadeIn 0.5s ease;
    }

    .content.active {
      display: block;
    }

    .card {
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 25px;
      color: #333;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      animation: slideUp 0.6s ease;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.4);
    }

    .card h3 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.5rem;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }

    pre {
      background: linear-gradient(135deg, #1e1e1e 0%, #2d2d30 100%);
      color: #d4d4d4;
      padding: 20px;
      border-radius: 12px;
      overflow-x: auto;
      margin: 15px 0;
      border-left: 4px solid #667eea;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
      position: relative;
    }

    pre::before {
      content: 'C++';
      position: absolute;
      top: 8px;
      right: 12px;
      background: #667eea;
      color: #fff;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .output {
      background: linear-gradient(135deg, #f6f8fa 0%, #e9ecef 100%);
      border-left: 4px solid #28a745;
      padding: 15px;
      margin: 15px 0;
      border-radius: 8px;
      font-family: monospace;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .output strong {
      color: #28a745;
    }

    .explain {
      background: linear-gradient(135deg, #fff3cd 0%, #ffe69c 100%);
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 15px 0;
      border-radius: 8px;
      color: #856404;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .copy-btn {
      background: #667eea;
      color: #fff;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      margin-top: 10px;
      transition: all 0.3s ease;
    }

    .copy-btn:hover {
      background: #764ba2;
      transform: scale(1.05);
    }

    .copy-btn:active {
      transform: scale(0.95);
    }

    footer {
      text-align: center;
      padding: 40px 20px;
      opacity: 0.8;
      animation: fadeIn 1.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .badge {
      display: inline-block;
      background: #667eea;
      color: #fff;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
      margin-right: 8px;
      font-weight: bold;
    }

    code {
      background: rgba(103, 126, 234, 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      color: #667eea;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      .card {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéì COM 1305</h1>
      <p class="subtitle">Object Oriented Programming ‚Äî Answer Script</p>
    </header>

    <div class="tabs">
      <button class="tab-btn active" data-tab="q1">Question 1</button>
      <button class="tab-btn" data-tab="q2">Question 2</button>
      <button class="tab-btn" data-tab="q3">Question 3</button>
      <button class="tab-btn" data-tab="q4">Question 4</button>
      <button class="tab-btn" data-tab="q5">Question 5</button>
    </div>

    <div id="q1" class="content active">
      <div class="card">
        <h3><span class="badge">1(a)</span> CuriousAdder Constructor</h3>
        <div class="explain">
          <strong>üí° Key Concept:</strong> <strong>Constructor</strong> - A special member function that initializes objects when created. It has the same name as the class and no return type.<br><br>
          <strong>‚ö†Ô∏è Important:</strong> This code demonstrates operator precedence and side effects. The <code>++i</code> (pre-increment) increments <code>i</code> before using it, and the loop's <code>i++</code> increments again, causing <code>i</code> to jump by 2 each iteration (0‚Üí1‚Üí2, 2‚Üí3‚Üí4, 4‚Üí5‚Üí6).
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class CuriousAdder {
public:
    CuriousAdder() {
        for (int i = 0; i &lt; 5; i++) {
            cout &lt;&lt; ++i &lt;&lt; " ";
        }
    }
};

int main() {
    CuriousAdder ca;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 1 3 5</div>
      </div>

      <div class="card">
        <h3><span class="badge">1(b)</span> MadPrinter Class</h3>
        <div class="explain">
          <strong>üí° Key Concepts:</strong><br>
          ‚Ä¢ <strong>do-while loop:</strong> Executes at least once before checking condition<br>
          ‚Ä¢ <strong>while loop:</strong> Checks condition before executing<br>
          ‚Ä¢ <strong>Member initialization list:</strong> <code>: i(j)</code> initializes member variable efficiently<br><br>
          <strong>‚ö†Ô∏è Important:</strong> Post-increment <code>i++</code> returns the current value then increments, so it prints the value before incrementing.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class MadPrinter {
public:
    int i;
    MadPrinter(int j) : i(j) { }

    void madPrint() {
        if (i &lt;= 5) {
            do {
                cout &lt;&lt; (i++) &lt;&lt; " \n";
            } while (i &lt;= 5);
        } else {
            while (i &lt; 10) {
                cout &lt;&lt; (i++) &lt;&lt; " \n";
            }
        }
    }
};

int main() {
    int i = 0;
    cin &gt;&gt; i;
    MadPrinter mP(i);
    mP.madPrint();
    return 0;
}</code></pre>
        <div class="output">
          <strong>Input = 3:</strong> prints 3 4 5<br>
          <strong>Input = 9:</strong> prints 9
        </div>
      </div>

      <div class="card">
        <h3><span class="badge">1(c)</span> Dereference Operator (*)</h3>
        <div class="explain">
          <strong>üí° Definition:</strong> The <strong>dereference operator (*)</strong> accesses the value stored at the memory address held by a pointer.<br><br>
          <strong>üìå Key Points:</strong><br>
          ‚Ä¢ <code>&</code> (address-of) gets the memory address of a variable<br>
          ‚Ä¢ <code>*</code> (dereference) gets the value at that address<br>
          ‚Ä¢ Pointers store memory addresses, not actual values<br>
          ‚Ä¢ Dereferencing allows reading/modifying the pointed-to value
        </div>
        <pre><code>int x = 10;
int *p = &x;
cout &lt;&lt; *p; // prints 10</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">1(d)</span> FindArea Class</h3>
        <div class="explain">
          <strong>üí° OOP Principles:</strong><br>
          ‚Ä¢ <strong>Encapsulation:</strong> Data members (<code>a</code>, <code>b</code>) are private, hidden from external access<br>
          ‚Ä¢ <strong>Constructor:</strong> Initializes object with values when created<br>
          ‚Ä¢ <strong>Member function:</strong> <code>area()</code> operates on the object's data<br><br>
          <strong>‚ö†Ô∏è Note:</strong> This demonstrates creating objects on the stack (automatic storage) rather than using pointers/heap allocation.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class FindArea {
    int a, b;
public:
    FindArea(int a, int b) : a(a), b(b) {}
    void area() { cout &lt;&lt; a * b; }
};

int main() {
    FindArea obj(5, 10);
    obj.area();
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 50</div>
      </div>

      <div class="card">
        <h3><span class="badge">1(e)</span> Recursive Function</h3>
        <div class="explain">
          <strong>üí° Recursion Definition:</strong> A function that calls itself to solve a problem by breaking it into smaller subproblems.<br><br>
          <strong>üìå Essential Elements:</strong><br>
          ‚Ä¢ <strong>Base case:</strong> <code>if (i &lt;= 10)</code> - stops recursion<br>
          ‚Ä¢ <strong>Recursive case:</strong> <code>printNumbers(i + 1)</code> - calls itself with modified parameter<br>
          ‚Ä¢ <strong>Progress:</strong> Each call moves closer to base case<br><br>
          <strong>‚ö†Ô∏è Warning:</strong> Without a proper base case, recursion causes stack overflow!
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

void printNumbers(int i) {
    if (i &lt;= 10) {
        cout &lt;&lt; i &lt;&lt; " ";
        printNumbers(i + 1);
    }
}

int main() {
    printNumbers(0);
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 0 1 2 3 4 5 6 7 8 9 10</div>
      </div>

      <div class="card">
        <h3><span class="badge">1(f)</span> Enum for Days</h3>
        <div class="explain">
          <strong>üí° Enumeration (enum) Definition:</strong> A user-defined type consisting of named constants. Makes code more readable and type-safe.<br><br>
          <strong>üìå Important Points:</strong><br>
          ‚Ä¢ Values start at 0 by default (SUNDAY=0, MONDAY=1, etc.)<br>
          ‚Ä¢ Can assign custom values: <code>enum Day { SUNDAY=1, MONDAY, ... }</code><br>
          ‚Ä¢ Stored as integers internally<br>
          ‚Ä¢ Improves code clarity vs using "magic numbers"<br>
          ‚Ä¢ C++11 introduced <code>enum class</code> for stronger type safety
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY };

int main() {
    Day d = TUESDAY;
    cout &lt;&lt; d &lt;&lt; endl;
    const char* names[] = {"SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"};
    cout &lt;&lt; names[d] &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 2 and TUESDAY</div>
      </div>
    </div>

    <div id="q2" class="content">
      <div class="card">
        <h3><span class="badge">2(a)</span> Abstract Person Class with Inheritance</h3>
        <div class="explain">
          <strong>üí° Key OOP Concepts:</strong><br>
          ‚Ä¢ <strong>Abstract Class:</strong> Contains at least one pure virtual function (<code>= 0</code>), cannot be instantiated<br>
          ‚Ä¢ <strong>Pure Virtual Function:</strong> <code>virtual void getInfo() = 0;</code> must be overridden in derived classes<br>
          ‚Ä¢ <strong>Inheritance:</strong> Student and Teacher inherit from Person (IS-A relationship)<br>
          ‚Ä¢ <strong>Protected members:</strong> Accessible in derived classes but not outside<br>
          ‚Ä¢ <strong>Polymorphism:</strong> Different classes implement getInfo() differently<br><br>
          <strong>‚ö†Ô∏è Important:</strong> Virtual destructor is essential when using polymorphism to ensure proper cleanup of derived objects.
        </div>
        <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Person {
protected:
    string name;
    int age;
public:
    Person(string n, int a) : name(n), age(a) {}
    virtual void getInfo() = 0;
    virtual ~Person() = default;
};

class Student : public Person {
    string grade;
public:
    Student(string n, int a, string g) : Person(n,a), grade(g) {}
    void getInfo() override {
        cout &lt;&lt; "Student - Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; ", Grade: " &lt;&lt; grade &lt;&lt; endl;
    }
};

class Teacher : public Person {
    string subject;
public:
    Teacher(string n, int a, string s) : Person(n,a), subject(s) {}
    void getInfo() override {
        cout &lt;&lt; "Teacher - Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; ", Subject: " &lt;&lt; subject &lt;&lt; endl;
    }
};</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">2(b)</span> Main Function Demo</h3>
        <div class="explain">
          <strong>üí° Demonstrates:</strong><br>
          ‚Ä¢ Creating objects of derived classes<br>
          ‚Ä¢ Calling overridden virtual functions<br>
          ‚Ä¢ Each class provides its own implementation of getInfo()<br><br>
          <strong>üìå Runtime Polymorphism:</strong> If using pointers (<code>Person* p = new Student(...)</code>), the correct function is called based on actual object type, not pointer type.
        </div>
        <pre><code>int main() {
    Student s("Akalanka", 21, "A");
    Teacher t("Nishantha", 50, "OOF");
    s.getInfo();
    t.getInfo();
    return 0;
}</code></pre>
        <div class="output">
          <strong>Output:</strong><br>
          Student - Name: Akalanka, Age: 21, Grade: A<br>
          Teacher - Name: Nishantha, Age: 50, Subject: OOF
        </div>
      </div>

      <div class="card">
        <h3><span class="badge">2(c)</span> Struct Book</h3>
        <div class="explain">
          <strong>üí° Struct vs Class:</strong><br>
          ‚Ä¢ <strong>struct:</strong> Members are public by default<br>
          ‚Ä¢ <strong>class:</strong> Members are private by default<br>
          ‚Ä¢ Both can have constructors, methods, inheritance<br>
          ‚Ä¢ Convention: Use struct for simple data containers, class for objects with behavior<br><br>
          <strong>üìå Best Practice:</strong> Structs typically represent Plain Old Data (POD) types without complex logic.
        </div>
        <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

struct book {
    int bookID;
    int numOfCopies;
    float price;
    string bookName;
};

int main() {
    book b;
    b.bookID = 101;
    b.numOfCopies = 5;
    b.price = 1499.99f;
    b.bookName = "Fundamentals of OOP";
    cout &lt;&lt; "BookID: " &lt;&lt; b.bookID &lt;&lt; ", Copies: " &lt;&lt; b.numOfCopies 
         &lt;&lt; ", Price: " &lt;&lt; b.price &lt;&lt; ", Name: " &lt;&lt; b.bookName &lt;&lt; endl;
    return 0;
}</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">2(d)</span> Pointers and References</h3>
        <div class="explain">
          <strong>üí° Critical Concepts:</strong><br>
          ‚Ä¢ <strong>Pointer (<code>*</code>):</strong> Variable storing memory address, can be reassigned, can be null<br>
          ‚Ä¢ <strong>Reference (<code>&</code>):</strong> Alias for existing variable, cannot be reassigned, must be initialized<br>
          ‚Ä¢ <strong>Address-of (<code>&</code>):</strong> Gets memory address of a variable<br>
          ‚Ä¢ <strong>Dereference (<code>*</code>):</strong> Accesses value at address<br><br>
          <strong>‚ö†Ô∏è Key Difference:</strong><br>
          ‚Ä¢ <code>number01</code> is a copy (changes don't affect original)<br>
          ‚Ä¢ <code>number02</code> is a pointer (can point to different addresses)<br>
          ‚Ä¢ <code>number03</code> is a reference (always refers to same variable)
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    double number = 1000;
    double number01 = number;
    double *number02 = &number;
    double &number03 = *number02;

    cout &lt;&lt; number &lt;&lt; endl;
    *number02 = *number02 * 2;
    cout &lt;&lt; *number02 &lt;&lt; endl;
    cout &lt;&lt; number03 &lt;&lt; endl;

    number02 = &number01;
    cout &lt;&lt; *number02 &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 1000, 2000, 2000, 1000</div>
      </div>

      <div class="card">
        <h3><span class="badge">2(e)</span> While Loop Conversion</h3>
        <div class="explain">
          <strong>üí° Loop Conversion Guide:</strong><br>
          <strong>For loop structure:</strong> <code>for(init; condition; increment) { body }</code><br>
          <strong>While loop equivalent:</strong><br>
          1. <code>init</code> before loop<br>
          2. <code>while(condition) { body; increment; }</code><br><br>
          <strong>üìå Loop Types:</strong><br>
          ‚Ä¢ <strong>for:</strong> Best when iteration count is known<br>
          ‚Ä¢ <strong>while:</strong> Best when condition-based<br>
          ‚Ä¢ <strong>do-while:</strong> Executes at least once
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int i = 0;
    while (i &lt; 5) {
        cout &lt;&lt; i &lt;&lt; " ";
        i++;
    }
    return 0;
}</code></pre>
      </div>
    </div>

    <div id="q3" class="content">
      <div class="card">
        <h3><span class="badge">3(a)</span> Multiple Inheritance Ambiguity</h3>
        <div class="explain">
          <strong>üí° Multiple Inheritance:</strong> A class inherits from multiple base classes.<br><br>
          <strong>‚ö†Ô∏è Diamond Problem:</strong> When two parent classes inherit from the same grandparent, causing ambiguity.<br><br>
          <strong>üìå Solutions:</strong><br>
          1. <strong>Scope Resolution:</strong> <code>B::hello()</code> explicitly specifies which base class<br>
          2. <strong>Virtual Inheritance:</strong> <code>class B : virtual public A</code> creates single shared base object<br><br>
          <strong>Best Practice:</strong> Prefer composition over multiple inheritance when possible to avoid complexity.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class A {
public:
    void hello() { cout &lt;&lt; "Hello from A\n"; }
};

class B : public A { };
class C : public A { };

class D : public B, public C {
public:
    void call() {
        B::hello(); // resolves to B's A::hello
        C::hello(); // resolves to C's A::hello
    }
};

int main() {
    D d;
    d.call();
    return 0;
}</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">3(b)</span> Calculator with Overloaded add</h3>
        <div class="explain">
          <strong>üí° Function Overloading (Compile-time Polymorphism):</strong><br>
          Multiple functions with same name but different parameters.<br><br>
          <strong>üìå Overloading Rules:</strong><br>
          ‚Ä¢ Different number of parameters<br>
          ‚Ä¢ Different parameter types<br>
          ‚Ä¢ Different parameter order<br>
          ‚Ä¢ <strong>NOT</strong> different return types alone<br><br>
          <strong>‚ö†Ô∏è Important:</strong> Compiler determines which function to call based on arguments at compile-time (static binding).<br><br>
          <strong>Use Cases:</strong> Provides intuitive interface - same operation on different data types.
        </div>
        <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Calculator {
public:
    int add(int a, int b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
    double add(double a, double b) { return a + b; }
    string add(const string &a, const string &b) { return a + b; }
};

int main() {
    Calculator calc;
    cout &lt;&lt; calc.add(2,3) &lt;&lt; endl;
    cout &lt;&lt; calc.add(1,2,3) &lt;&lt; endl;
    cout &lt;&lt; calc.add(1.5,2.25) &lt;&lt; endl;
    cout &lt;&lt; calc.add(string("Hello "), string("World")) &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 5, 6, 3.75, Hello World</div>
      </div>

      <div class="card">
        <h3><span class="badge">3(c)</span> Copy Constructor</h3>
        <div class="explain">
          <strong>üí° Copy Constructor Definition:</strong> Special constructor that creates a new object as a copy of an existing object.<br><br>
          <strong>üìå Signature:</strong> <code>ClassName(const ClassName& other)</code><br><br>
          <strong>When Called:</strong><br>
          ‚Ä¢ Object initialization: <code>Example e2 = e1;</code><br>
          ‚Ä¢ Pass by value to functions<br>
          ‚Ä¢ Return by value from functions<br><br>
          <strong>‚ö†Ô∏è Deep vs Shallow Copy:</strong><br>
          ‚Ä¢ <strong>Shallow:</strong> Default copy - copies member values (dangerous with pointers!)<br>
          ‚Ä¢ <strong>Deep:</strong> Custom copy - allocates new memory for pointer members<br><br>
          <strong>Rule of Three:</strong> If you define copy constructor, also define destructor and assignment operator.
        </div>
        <pre><code>class Example {
    int value;
public:
    Example(int v): value(v) {}
    Example(const Example &other): value(other.value) {}
};</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">3(d)</span> Destructor</h3>
        <div class="explain">
          <strong>üí° Destructor Definition:</strong> Special member function called when object is destroyed. Name: <code>~ClassName()</code><br><br>
          <strong>üìå Key Characteristics:</strong><br>
          ‚Ä¢ Same name as class with <code>~</code> prefix<br>
          ‚Ä¢ No parameters, no return type<br>
          ‚Ä¢ Only one destructor per class<br>
          ‚Ä¢ Cannot be overloaded<br>
          ‚Ä¢ Called automatically when object goes out of scope<br><br>
          <strong>‚ö†Ô∏è Essential Uses:</strong><br>
          ‚Ä¢ Release dynamically allocated memory<br>
          ‚Ä¢ Close file handles<br>
          ‚Ä¢ Release system resources<br>
          ‚Ä¢ Clean up network connections<br><br>
          <strong>Virtual Destructor:</strong> Use <code>virtual ~ClassName()</code> when class has virtual functions to ensure proper cleanup of derived objects.
        </div>
        <pre><code>class Demo {
public:
    Demo() { /* allocate resources */ }
    ~Demo() { /* free resources */ }
};</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">3(e)</span> getDist Implementation</h3>
        <div class="explain">
          <strong>üí° Member Function Definition Outside Class:</strong><br>
          ‚Ä¢ Declared inside class: <code>int getDist();</code><br>
          ‚Ä¢ Defined outside with scope resolution: <code>int Distance::getDist() { }</code><br><br>
          <strong>üìå Benefits:</strong><br>
          ‚Ä¢ Separates interface (header) from implementation (source)<br>
          ‚Ä¢ Improves code organization<br>
          ‚Ä¢ Reduces compilation dependencies<br>
          ‚Ä¢ Common pattern: declarations in .h, definitions in .cpp<br><br>
          <strong>‚ö†Ô∏è Scope Resolution Operator (<code>::</code>):</strong> Specifies that the function belongs to the Distance class.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class Distance {
private:
    int feet;
    int inches;
public:
    Distance(int feet, int inches) : feet(feet), inches(inches) {}
    int getDist();
};

int Distance::getDist() {
    return feet * 12 + inches;
}

int main() {
    Distance d(10, 5);
    cout &lt;&lt; d.getDist() &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 125</div>
      </div>
    </div>

    <div id="q4" class="content">
      <div class="card">
        <h3><span class="badge">4(c)</span> Temp Class with Access Specifiers</h3>
        <div class="explain">
          <strong>üí° Access Specifiers in C++:</strong><br><br>
          <strong>1. private:</strong> Accessible only within the class<br>
          <strong>2. public:</strong> Accessible from anywhere<br>
          <strong>3. protected:</strong> Accessible in class and derived classes<br><br>
          <strong>üìå Encapsulation Best Practice:</strong><br>
          ‚Ä¢ Keep data members private<br>
          ‚Ä¢ Provide public getter/setter methods<br>
          ‚Ä¢ Protects data from invalid modifications<br>
          ‚Ä¢ Allows changing internal implementation without affecting users<br><br>
          <strong>‚ö†Ô∏è const Member Function:</strong> <code>getTemp() const</code> promises not to modify object state.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class Temp {
private:
    double celc;
public:
    Temp(double t) : celc(t) {}
    void setTemp(double t) { celc = t; }
    double getTemp() const { return celc; }
};

int main() {
    Temp temp1(35);
    Temp temp2 = temp1;
    temp2.setTemp(40);
    cout &lt;&lt; "temp1: " &lt;&lt; temp1.getTemp() 
         &lt;&lt; ", temp2: " &lt;&lt; temp2.getTemp() &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> temp1: 35, temp2: 40</div>
      </div>

      <div class="card">
        <h3><span class="badge">4(d)</span> Friend Function getCat</h3>
        <div class="explain">
          <strong>üí° Friend Function Definition:</strong> A non-member function that has access to private/protected members of a class.<br><br>
          <strong>üìå Declaration:</strong> <code>friend ReturnType functionName(params);</code><br><br>
          <strong>Key Characteristics:</strong><br>
          ‚Ä¢ Not a member of the class<br>
          ‚Ä¢ Can access private/protected members<br>
          ‚Ä¢ Declared inside class with <code>friend</code> keyword<br>
          ‚Ä¢ Defined outside without <code>friend</code> keyword<br>
          ‚Ä¢ Not inherited by derived classes<br><br>
          <strong>‚ö†Ô∏è Use Cases:</strong><br>
          ‚Ä¢ Operator overloading (<code>friend ostream& operator<<</code>)<br>
          ‚Ä¢ Factory functions<br>
          ‚Ä¢ Granting access to specific external functions<br><br>
          <strong>Caution:</strong> Breaks encapsulation - use sparingly!
        </div>
        <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Cat {
private:
    string name;
    int age;
public:
    Cat(string name, int age) : name(name), age(age) {}
    void sayCat() { 
        cout &lt;&lt; "Cat: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; endl; 
    }
    friend Cat getCat(const string &n, int a);
};

Cat getCat(const string &n, int a) {
    return Cat(n, a);
}

int main() {
    Cat cat = getCat("Tom", 10);
    cat.sayCat();
    return 0;
}</code></pre>
      </div>

      <div class="card">
        <h3><span class="badge">4(e)</span> Operator Overloading</h3>
        <div class="explain">
          <strong>üí° Operator Overloading:</strong> Giving new meaning to existing operators for user-defined types.<br><br>
          <strong>üìå Syntax:</strong> <code>ReturnType operator@(parameters)</code><br>
          where @ is the operator being overloaded<br><br>
          <strong>Commonly Overloaded:</strong><br>
          ‚Ä¢ Arithmetic: +, -, *, /<br>
          ‚Ä¢ Comparison: ==, !=, &lt;, &gt;, &lt;=, &gt;=<br>
          ‚Ä¢ Assignment: =<br>
          ‚Ä¢ Stream: &lt;&lt;, &gt;&gt;<br>
          ‚Ä¢ Subscript: []<br>
          ‚Ä¢ Function call: ()<br><br>
          <strong>‚ö†Ô∏è Cannot Overload:</strong> <code>::, ., .*, ?:, sizeof, typeid</code><br><br>
          <strong>Best Practice:</strong> Overload operators intuitively - behavior should match user expectations.
        </div>
        <pre><code>#include &lt;iostream&gt;
using namespace std;

class Distance {
private:
    int feet;
    float inches;
public:
    Distance(int ft, float in) : feet(ft), inches(in) {}
    float totalInches() const { return feet * 12.0f + inches; }
    bool operator&lt;(const Distance &d2) const {
        return totalInches() &lt; d2.totalInches();
    }
    bool operator==(const Distance &d2) const {
        return totalInches() == d2.totalInches();
    }
};

int main() {
    Distance d1(1, 10.5f);
    Distance d2(2, 10.5f);
    cout &lt;&lt; (d1 &lt; d2) &lt;&lt; endl;
    return 0;
}</code></pre>
        <div class="output"><strong>Output:</strong> 1 (true)</div>
      </div>
    </div>

    <div id="q5" class="content">
      <div class="card">
        <h3><span class="badge">5(a)</span> Car Class with Static Members</h3>
        <div class="explain">
          <strong>üí° Static Members:</strong> Belong to the class itself, not individual objects. Shared across all instances.<br><br>
          <strong>üìå Static Data Members:</strong><br>
          ‚Ä¢ Declared with <code>static</code> keyword<br>
          ‚Ä¢ Must be defined outside class: <code>int Car::totalCars = 0;</code><br>
          ‚Ä¢ Shared by all objects of the class<br>
          ‚Ä¢ Accessed via class name: <code>Car::totalCars</code><br>
          ‚Ä¢ Exists even before any objects created<br><br>
          <strong>Static Member Functions:</strong><br>
          ‚Ä¢ Can only access static members<br>
          ‚Ä¢ No <code>this</code> pointer<br>
          ‚Ä¢ Called using class name: <code>Car::displayTotalCarNo()</code><br><br>
          <strong>‚ö†Ô∏è Use Cases:</strong> Counters, factory methods, utility functions, constants shared across instances.
        </div>
        <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Car {
private:
    string brand;
    string model;
    static int totalCars;
public:
    Car(const string &b, const string &m) : brand(b), model(m) {
        totalCars++;
    }
    void displayCarData() const {
        cout &lt;&lt; "Brand: " &lt;&lt; brand &lt;&lt; ", Model: " &lt;&lt; model &lt;&lt; endl;
    }
    static void displayTotalCarNo() {
        cout &lt;&lt; "Total cars: " &lt;&lt; totalCars &lt;&lt; endl;
    }
};

int Car::totalCars = 0;

int main() {
    Car::displayTotalCarNo();
    Car car1("Toyota", "Vitz");
    Car car2("Honda", "Vezel");
    car1.displayCarData();
    car2.displayCarData();
    Car::displayTotalCarNo();
    return 0;
}</code></pre>
        <div class="output">
          <strong>Output:</strong><br>
          Total cars: 0<br>
          Brand: Toyota, Model: Vitz<br>
          Brand: Honda, Model: Vezel<br>
          Total cars: 2
        </div>
      </div>

      <div class="card">
        <h3><span class="badge">5(e)</span> Const Keyword & Observer Pattern</h3>
        <div class="explain">
          <strong>üí° const Keyword Usage:</strong><br><br>
          <strong>1. const Variables:</strong> <code>const int x = 5;</code> - cannot be modified<br>
          <strong>2. const Pointers:</strong><br>
          ‚Ä¢ <code>const int* p</code> - pointer to constant data<br>
          ‚Ä¢ <code>int* const p</code> - constant pointer<br>
          ‚Ä¢ <code>const int* const p</code> - constant pointer to constant data<br>
          <strong>3. const Member Functions:</strong> <code>int getValue() const;</code><br>
          ‚Ä¢ Promises not to modify object state<br>
          ‚Ä¢ Can be called on const objects<br>
          ‚Ä¢ Can only call other const member functions<br><br>
          <strong>üìå Benefits:</strong> Compile-time safety, optimization opportunities, clearer intent
        </div>
        <div class="explain" style="margin-top: 15px;">
          <strong>üéØ Observer Pattern (Behavioral Design Pattern):</strong><br><br>
          <strong>Definition:</strong> Defines one-to-many dependency - when subject changes state, all observers are notified automatically.<br><br>
          <strong>Components:</strong><br>
          ‚Ä¢ <strong>Subject:</strong> Maintains list of observers, provides attach/detach methods<br>
          ‚Ä¢ <strong>Observer:</strong> Interface with update() method<br>
          ‚Ä¢ <strong>ConcreteSubject:</strong> Stores state, notifies observers on changes<br>
          ‚Ä¢ <strong>ConcreteObserver:</strong> Implements update() to respond to changes<br><br>
          <strong>Real-World Examples:</strong><br>
          ‚Ä¢ GUI event handling (button clicks notify listeners)<br>
          ‚Ä¢ MVC architecture (model notifies views)<br>
          ‚Ä¢ Pub-Sub systems<br>
          ‚Ä¢ Social media notifications<br><br>
          <strong>‚ö†Ô∏è Benefits:</strong> Loose coupling, dynamic relationships, broadcast communication
        </div>
      </div>
    </div>

    <footer>
      <p>‚ú® Interactive OOP Answer Script</p>
      <p style="opacity: 0.7; margin-top: 10px;">Click tabs to navigate between questions</p>
    </footer>
  </div>

  <script>
    const tabs = document.querySelectorAll('.tab-btn');
    const contents = document.querySelectorAll('.content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;
        
        tabs.forEach(t => t.classList.remove('active'));
        contents.forEach(c => c.classList.remove('active'));
        
        tab.classList.add('active');
        document.getElementById(target).classList.add('active');
      });
    });

    document.querySelectorAll('pre').forEach(pre => {
      const btn = document.createElement('button');
      btn.textContent = 'Copy Code';
      btn.className = 'copy-btn';
      btn.addEventListener('click', () => {
        const code = pre.textContent.replace('C++', '').trim();
        navigator.clipboard.writeText(code).then(() => {
          btn.textContent = 'Copied!';
          setTimeout(() => btn.textContent = 'Copy Code', 2000);
        });
      });
      pre.appendChild(btn);
    });
  </script>
</body>
</html>